#pragma version 9

// This TEAL was generated by TEALScript v0.63.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// and(uint64,uint64)void
abi_route_and:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute and(uint64,uint64)void
	callsub and
	int 1
	return

and:
	proto 2 0

	// tests/contracts/binary.algo.ts:6
	// assert(a && b)
	frame_dig -1 // a: uint64
	dup
	bz skip_and0
	frame_dig -2 // b: uint64
	&&

skip_and0:
	assert
	retsub

// or(uint64,uint64)void
abi_route_or:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute or(uint64,uint64)void
	callsub or
	int 1
	return

or:
	proto 2 0

	// tests/contracts/binary.algo.ts:10
	// assert(a || b)
	frame_dig -1 // a: uint64
	dup
	bnz skip_or0
	frame_dig -2 // b: uint64
	||

skip_or0:
	assert
	retsub

// equal(uint64,uint64)void
abi_route_equal:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute equal(uint64,uint64)void
	callsub equal
	int 1
	return

equal:
	proto 2 0

	// tests/contracts/binary.algo.ts:14
	// assert(a === b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	==
	assert
	retsub

// notEqual(uint64,uint64)void
abi_route_notEqual:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute notEqual(uint64,uint64)void
	callsub notEqual
	int 1
	return

notEqual:
	proto 2 0

	// tests/contracts/binary.algo.ts:18
	// assert(a !== b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	!=
	assert
	retsub

// bitAnd(uint64,uint64)void
abi_route_bitAnd:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitAnd(uint64,uint64)void
	callsub bitAnd
	int 1
	return

bitAnd:
	proto 2 0

	// tests/contracts/binary.algo.ts:22
	// assert(a & b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	&
	assert
	retsub

// bitOr(uint64,uint64)void
abi_route_bitOr:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitOr(uint64,uint64)void
	callsub bitOr
	int 1
	return

bitOr:
	proto 2 0

	// tests/contracts/binary.algo.ts:26
	// assert(a | b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	|
	assert
	retsub

// bitXor(uint64,uint64)void
abi_route_bitXor:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitXor(uint64,uint64)void
	callsub bitXor
	int 1
	return

bitXor:
	proto 2 0

	// tests/contracts/binary.algo.ts:30
	// assert(a ^ b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	^
	assert
	retsub

// combo(uint64,uint64,uint64)void
abi_route_combo:
	// c: uint64
	txna ApplicationArgs 3
	btoi

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute combo(uint64,uint64,uint64)void
	callsub combo
	int 1
	return

combo:
	proto 3 0

	// tests/contracts/binary.algo.ts:34
	// assert(a || (b && c))
	frame_dig -1 // a: uint64
	dup
	bnz skip_or1
	frame_dig -2 // b: uint64
	dup
	bz skip_and1
	frame_dig -3 // c: uint64
	&&

skip_and1:
	||

skip_or1:
	assert
	retsub

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "and(uint64,uint64)void"
	method "or(uint64,uint64)void"
	method "equal(uint64,uint64)void"
	method "notEqual(uint64,uint64)void"
	method "bitAnd(uint64,uint64)void"
	method "bitOr(uint64,uint64)void"
	method "bitXor(uint64,uint64)void"
	method "combo(uint64,uint64,uint64)void"
	txna ApplicationArgs 0
	match abi_route_and abi_route_or abi_route_equal abi_route_notEqual abi_route_bitAnd abi_route_bitOr abi_route_bitXor abi_route_combo
	err